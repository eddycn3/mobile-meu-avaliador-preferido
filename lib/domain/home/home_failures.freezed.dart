// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named

part of 'home_failures.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

class _$HomeFailureTearOff {
  const _$HomeFailureTearOff();

  UserInfoNotFound userInfoNotFound() {
    return const UserInfoNotFound();
  }

  NoTokenProvided noTokenProvided() {
    return const NoTokenProvided();
  }

  TokenError tokenError() {
    return const TokenError();
  }

  TokenMalformed tokenMalformed() {
    return const TokenMalformed();
  }

  InvalidToken invalidToken() {
    return const InvalidToken();
  }
}

// ignore: unused_element
const $HomeFailure = _$HomeFailureTearOff();

mixin _$HomeFailure {
  @optionalTypeArgs
  Result when<Result extends Object>({
    @required Result userInfoNotFound(),
    @required Result noTokenProvided(),
    @required Result tokenError(),
    @required Result tokenMalformed(),
    @required Result invalidToken(),
  });
  @optionalTypeArgs
  Result maybeWhen<Result extends Object>({
    Result userInfoNotFound(),
    Result noTokenProvided(),
    Result tokenError(),
    Result tokenMalformed(),
    Result invalidToken(),
    @required Result orElse(),
  });
  @optionalTypeArgs
  Result map<Result extends Object>({
    @required Result userInfoNotFound(UserInfoNotFound value),
    @required Result noTokenProvided(NoTokenProvided value),
    @required Result tokenError(TokenError value),
    @required Result tokenMalformed(TokenMalformed value),
    @required Result invalidToken(InvalidToken value),
  });
  @optionalTypeArgs
  Result maybeMap<Result extends Object>({
    Result userInfoNotFound(UserInfoNotFound value),
    Result noTokenProvided(NoTokenProvided value),
    Result tokenError(TokenError value),
    Result tokenMalformed(TokenMalformed value),
    Result invalidToken(InvalidToken value),
    @required Result orElse(),
  });
}

abstract class $HomeFailureCopyWith<$Res> {
  factory $HomeFailureCopyWith(
          HomeFailure value, $Res Function(HomeFailure) then) =
      _$HomeFailureCopyWithImpl<$Res>;
}

class _$HomeFailureCopyWithImpl<$Res> implements $HomeFailureCopyWith<$Res> {
  _$HomeFailureCopyWithImpl(this._value, this._then);

  final HomeFailure _value;
  // ignore: unused_field
  final $Res Function(HomeFailure) _then;
}

abstract class $UserInfoNotFoundCopyWith<$Res> {
  factory $UserInfoNotFoundCopyWith(
          UserInfoNotFound value, $Res Function(UserInfoNotFound) then) =
      _$UserInfoNotFoundCopyWithImpl<$Res>;
}

class _$UserInfoNotFoundCopyWithImpl<$Res>
    extends _$HomeFailureCopyWithImpl<$Res>
    implements $UserInfoNotFoundCopyWith<$Res> {
  _$UserInfoNotFoundCopyWithImpl(
      UserInfoNotFound _value, $Res Function(UserInfoNotFound) _then)
      : super(_value, (v) => _then(v as UserInfoNotFound));

  @override
  UserInfoNotFound get _value => super._value as UserInfoNotFound;
}

class _$UserInfoNotFound implements UserInfoNotFound {
  const _$UserInfoNotFound();

  @override
  String toString() {
    return 'HomeFailure.userInfoNotFound()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) || (other is UserInfoNotFound);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  Result when<Result extends Object>({
    @required Result userInfoNotFound(),
    @required Result noTokenProvided(),
    @required Result tokenError(),
    @required Result tokenMalformed(),
    @required Result invalidToken(),
  }) {
    assert(userInfoNotFound != null);
    assert(noTokenProvided != null);
    assert(tokenError != null);
    assert(tokenMalformed != null);
    assert(invalidToken != null);
    return userInfoNotFound();
  }

  @override
  @optionalTypeArgs
  Result maybeWhen<Result extends Object>({
    Result userInfoNotFound(),
    Result noTokenProvided(),
    Result tokenError(),
    Result tokenMalformed(),
    Result invalidToken(),
    @required Result orElse(),
  }) {
    assert(orElse != null);
    if (userInfoNotFound != null) {
      return userInfoNotFound();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  Result map<Result extends Object>({
    @required Result userInfoNotFound(UserInfoNotFound value),
    @required Result noTokenProvided(NoTokenProvided value),
    @required Result tokenError(TokenError value),
    @required Result tokenMalformed(TokenMalformed value),
    @required Result invalidToken(InvalidToken value),
  }) {
    assert(userInfoNotFound != null);
    assert(noTokenProvided != null);
    assert(tokenError != null);
    assert(tokenMalformed != null);
    assert(invalidToken != null);
    return userInfoNotFound(this);
  }

  @override
  @optionalTypeArgs
  Result maybeMap<Result extends Object>({
    Result userInfoNotFound(UserInfoNotFound value),
    Result noTokenProvided(NoTokenProvided value),
    Result tokenError(TokenError value),
    Result tokenMalformed(TokenMalformed value),
    Result invalidToken(InvalidToken value),
    @required Result orElse(),
  }) {
    assert(orElse != null);
    if (userInfoNotFound != null) {
      return userInfoNotFound(this);
    }
    return orElse();
  }
}

abstract class UserInfoNotFound implements HomeFailure {
  const factory UserInfoNotFound() = _$UserInfoNotFound;
}

abstract class $NoTokenProvidedCopyWith<$Res> {
  factory $NoTokenProvidedCopyWith(
          NoTokenProvided value, $Res Function(NoTokenProvided) then) =
      _$NoTokenProvidedCopyWithImpl<$Res>;
}

class _$NoTokenProvidedCopyWithImpl<$Res>
    extends _$HomeFailureCopyWithImpl<$Res>
    implements $NoTokenProvidedCopyWith<$Res> {
  _$NoTokenProvidedCopyWithImpl(
      NoTokenProvided _value, $Res Function(NoTokenProvided) _then)
      : super(_value, (v) => _then(v as NoTokenProvided));

  @override
  NoTokenProvided get _value => super._value as NoTokenProvided;
}

class _$NoTokenProvided implements NoTokenProvided {
  const _$NoTokenProvided();

  @override
  String toString() {
    return 'HomeFailure.noTokenProvided()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) || (other is NoTokenProvided);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  Result when<Result extends Object>({
    @required Result userInfoNotFound(),
    @required Result noTokenProvided(),
    @required Result tokenError(),
    @required Result tokenMalformed(),
    @required Result invalidToken(),
  }) {
    assert(userInfoNotFound != null);
    assert(noTokenProvided != null);
    assert(tokenError != null);
    assert(tokenMalformed != null);
    assert(invalidToken != null);
    return noTokenProvided();
  }

  @override
  @optionalTypeArgs
  Result maybeWhen<Result extends Object>({
    Result userInfoNotFound(),
    Result noTokenProvided(),
    Result tokenError(),
    Result tokenMalformed(),
    Result invalidToken(),
    @required Result orElse(),
  }) {
    assert(orElse != null);
    if (noTokenProvided != null) {
      return noTokenProvided();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  Result map<Result extends Object>({
    @required Result userInfoNotFound(UserInfoNotFound value),
    @required Result noTokenProvided(NoTokenProvided value),
    @required Result tokenError(TokenError value),
    @required Result tokenMalformed(TokenMalformed value),
    @required Result invalidToken(InvalidToken value),
  }) {
    assert(userInfoNotFound != null);
    assert(noTokenProvided != null);
    assert(tokenError != null);
    assert(tokenMalformed != null);
    assert(invalidToken != null);
    return noTokenProvided(this);
  }

  @override
  @optionalTypeArgs
  Result maybeMap<Result extends Object>({
    Result userInfoNotFound(UserInfoNotFound value),
    Result noTokenProvided(NoTokenProvided value),
    Result tokenError(TokenError value),
    Result tokenMalformed(TokenMalformed value),
    Result invalidToken(InvalidToken value),
    @required Result orElse(),
  }) {
    assert(orElse != null);
    if (noTokenProvided != null) {
      return noTokenProvided(this);
    }
    return orElse();
  }
}

abstract class NoTokenProvided implements HomeFailure {
  const factory NoTokenProvided() = _$NoTokenProvided;
}

abstract class $TokenErrorCopyWith<$Res> {
  factory $TokenErrorCopyWith(
          TokenError value, $Res Function(TokenError) then) =
      _$TokenErrorCopyWithImpl<$Res>;
}

class _$TokenErrorCopyWithImpl<$Res> extends _$HomeFailureCopyWithImpl<$Res>
    implements $TokenErrorCopyWith<$Res> {
  _$TokenErrorCopyWithImpl(TokenError _value, $Res Function(TokenError) _then)
      : super(_value, (v) => _then(v as TokenError));

  @override
  TokenError get _value => super._value as TokenError;
}

class _$TokenError implements TokenError {
  const _$TokenError();

  @override
  String toString() {
    return 'HomeFailure.tokenError()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) || (other is TokenError);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  Result when<Result extends Object>({
    @required Result userInfoNotFound(),
    @required Result noTokenProvided(),
    @required Result tokenError(),
    @required Result tokenMalformed(),
    @required Result invalidToken(),
  }) {
    assert(userInfoNotFound != null);
    assert(noTokenProvided != null);
    assert(tokenError != null);
    assert(tokenMalformed != null);
    assert(invalidToken != null);
    return tokenError();
  }

  @override
  @optionalTypeArgs
  Result maybeWhen<Result extends Object>({
    Result userInfoNotFound(),
    Result noTokenProvided(),
    Result tokenError(),
    Result tokenMalformed(),
    Result invalidToken(),
    @required Result orElse(),
  }) {
    assert(orElse != null);
    if (tokenError != null) {
      return tokenError();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  Result map<Result extends Object>({
    @required Result userInfoNotFound(UserInfoNotFound value),
    @required Result noTokenProvided(NoTokenProvided value),
    @required Result tokenError(TokenError value),
    @required Result tokenMalformed(TokenMalformed value),
    @required Result invalidToken(InvalidToken value),
  }) {
    assert(userInfoNotFound != null);
    assert(noTokenProvided != null);
    assert(tokenError != null);
    assert(tokenMalformed != null);
    assert(invalidToken != null);
    return tokenError(this);
  }

  @override
  @optionalTypeArgs
  Result maybeMap<Result extends Object>({
    Result userInfoNotFound(UserInfoNotFound value),
    Result noTokenProvided(NoTokenProvided value),
    Result tokenError(TokenError value),
    Result tokenMalformed(TokenMalformed value),
    Result invalidToken(InvalidToken value),
    @required Result orElse(),
  }) {
    assert(orElse != null);
    if (tokenError != null) {
      return tokenError(this);
    }
    return orElse();
  }
}

abstract class TokenError implements HomeFailure {
  const factory TokenError() = _$TokenError;
}

abstract class $TokenMalformedCopyWith<$Res> {
  factory $TokenMalformedCopyWith(
          TokenMalformed value, $Res Function(TokenMalformed) then) =
      _$TokenMalformedCopyWithImpl<$Res>;
}

class _$TokenMalformedCopyWithImpl<$Res> extends _$HomeFailureCopyWithImpl<$Res>
    implements $TokenMalformedCopyWith<$Res> {
  _$TokenMalformedCopyWithImpl(
      TokenMalformed _value, $Res Function(TokenMalformed) _then)
      : super(_value, (v) => _then(v as TokenMalformed));

  @override
  TokenMalformed get _value => super._value as TokenMalformed;
}

class _$TokenMalformed implements TokenMalformed {
  const _$TokenMalformed();

  @override
  String toString() {
    return 'HomeFailure.tokenMalformed()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) || (other is TokenMalformed);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  Result when<Result extends Object>({
    @required Result userInfoNotFound(),
    @required Result noTokenProvided(),
    @required Result tokenError(),
    @required Result tokenMalformed(),
    @required Result invalidToken(),
  }) {
    assert(userInfoNotFound != null);
    assert(noTokenProvided != null);
    assert(tokenError != null);
    assert(tokenMalformed != null);
    assert(invalidToken != null);
    return tokenMalformed();
  }

  @override
  @optionalTypeArgs
  Result maybeWhen<Result extends Object>({
    Result userInfoNotFound(),
    Result noTokenProvided(),
    Result tokenError(),
    Result tokenMalformed(),
    Result invalidToken(),
    @required Result orElse(),
  }) {
    assert(orElse != null);
    if (tokenMalformed != null) {
      return tokenMalformed();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  Result map<Result extends Object>({
    @required Result userInfoNotFound(UserInfoNotFound value),
    @required Result noTokenProvided(NoTokenProvided value),
    @required Result tokenError(TokenError value),
    @required Result tokenMalformed(TokenMalformed value),
    @required Result invalidToken(InvalidToken value),
  }) {
    assert(userInfoNotFound != null);
    assert(noTokenProvided != null);
    assert(tokenError != null);
    assert(tokenMalformed != null);
    assert(invalidToken != null);
    return tokenMalformed(this);
  }

  @override
  @optionalTypeArgs
  Result maybeMap<Result extends Object>({
    Result userInfoNotFound(UserInfoNotFound value),
    Result noTokenProvided(NoTokenProvided value),
    Result tokenError(TokenError value),
    Result tokenMalformed(TokenMalformed value),
    Result invalidToken(InvalidToken value),
    @required Result orElse(),
  }) {
    assert(orElse != null);
    if (tokenMalformed != null) {
      return tokenMalformed(this);
    }
    return orElse();
  }
}

abstract class TokenMalformed implements HomeFailure {
  const factory TokenMalformed() = _$TokenMalformed;
}

abstract class $InvalidTokenCopyWith<$Res> {
  factory $InvalidTokenCopyWith(
          InvalidToken value, $Res Function(InvalidToken) then) =
      _$InvalidTokenCopyWithImpl<$Res>;
}

class _$InvalidTokenCopyWithImpl<$Res> extends _$HomeFailureCopyWithImpl<$Res>
    implements $InvalidTokenCopyWith<$Res> {
  _$InvalidTokenCopyWithImpl(
      InvalidToken _value, $Res Function(InvalidToken) _then)
      : super(_value, (v) => _then(v as InvalidToken));

  @override
  InvalidToken get _value => super._value as InvalidToken;
}

class _$InvalidToken implements InvalidToken {
  const _$InvalidToken();

  @override
  String toString() {
    return 'HomeFailure.invalidToken()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) || (other is InvalidToken);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  Result when<Result extends Object>({
    @required Result userInfoNotFound(),
    @required Result noTokenProvided(),
    @required Result tokenError(),
    @required Result tokenMalformed(),
    @required Result invalidToken(),
  }) {
    assert(userInfoNotFound != null);
    assert(noTokenProvided != null);
    assert(tokenError != null);
    assert(tokenMalformed != null);
    assert(invalidToken != null);
    return invalidToken();
  }

  @override
  @optionalTypeArgs
  Result maybeWhen<Result extends Object>({
    Result userInfoNotFound(),
    Result noTokenProvided(),
    Result tokenError(),
    Result tokenMalformed(),
    Result invalidToken(),
    @required Result orElse(),
  }) {
    assert(orElse != null);
    if (invalidToken != null) {
      return invalidToken();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  Result map<Result extends Object>({
    @required Result userInfoNotFound(UserInfoNotFound value),
    @required Result noTokenProvided(NoTokenProvided value),
    @required Result tokenError(TokenError value),
    @required Result tokenMalformed(TokenMalformed value),
    @required Result invalidToken(InvalidToken value),
  }) {
    assert(userInfoNotFound != null);
    assert(noTokenProvided != null);
    assert(tokenError != null);
    assert(tokenMalformed != null);
    assert(invalidToken != null);
    return invalidToken(this);
  }

  @override
  @optionalTypeArgs
  Result maybeMap<Result extends Object>({
    Result userInfoNotFound(UserInfoNotFound value),
    Result noTokenProvided(NoTokenProvided value),
    Result tokenError(TokenError value),
    Result tokenMalformed(TokenMalformed value),
    Result invalidToken(InvalidToken value),
    @required Result orElse(),
  }) {
    assert(orElse != null);
    if (invalidToken != null) {
      return invalidToken(this);
    }
    return orElse();
  }
}

abstract class InvalidToken implements HomeFailure {
  const factory InvalidToken() = _$InvalidToken;
}
